# DMN-Prolog Converter - Developer Guide

## ✅ Status: **Working Prototype**

The bidirectional Prolog ↔ DMN converter is fully functional for the constrained Prolog subset designed for legal/business rules.

## Quick Start

### 1. Installation

```bash
git clone https://github.dev/NewJerseyStyle/dmn_prolog_converter
cd dmn_prolog_converter
pip install -e .[dev]
```

### 2. Convert Files

```bash
# Prolog → DMN
python -m src.converter input.pl output.dmn

# DMN → Prolog
python -m src.converter input.dmn output.pl
```

## Python API

```python
from src.converter import PrologDMNConverter

converter = PrologDMNConverter()

# File-based conversion
dmn_xml = converter.prolog_to_dmn("rules.pl", "rules.dmn")
prolog_code = converter.dmn_to_prolog("rules.dmn", "rules.pl")

# String-based conversion
dmn_xml = converter.prolog_string_to_dmn(prolog_code)
prolog_code = converter.dmn_string_to_prolog(dmn_xml)

# Validate roundtrip
is_valid, message = converter.validate_roundtrip("rules.pl")
print(message)
```

## Supported Prolog Patterns

### ✅ Supported

```prolog
% Simple comparisons
determine_tax_rate(Income, TaxRate) :-
    Income >= 50000,
    TaxRate = 28.

% Multiple conditions (AND)
eligible_for_loan(Amount, Result) :-
    Credit >= 650,
    Income >= 30000,
    Result = approved.

% Arithmetic expressions
check_affordability(Income, Expense, Affordable) :-
    Income >= Expense * 3,
    Affordable = yes.

% Multiple rules for same decision
risk_level(Score, Risk) :- Score >= 80, Risk = low.
risk_level(Score, Risk) :- Score >= 50, Score < 80, Risk = medium.
risk_level(Score, Risk) :- Score < 50, Risk = high.
```

### ⚠️ Limitations

```prolog
% ❌ NOT supported - Negation as failure
not_risky(Score) :- \+ high_risk(Score).

% ❌ NOT supported - Cuts
best_option(X) :- good(X), !.

% ❌ NOT supported - Complex list operations
sum_list([H|T], Sum) :- sum_list(T, Rest), Sum is H + Rest.

% ⚠️ Partially supported - Complex arithmetic
% Simple arithmetic works, but complex expressions may lose precision
calculate(X, Y, Z) :- Z is X * Y + 10.  % Works
calculate(X, Y, Z) :- Z is sqrt(X^2 + Y^2).  % May not work correctly
```

## Example: Legal Rules Workflow

### Step 1: LLM Generates Prolog from Legal Document

```text
Legal Document:
"An applicant qualifies for a premium loan if their credit score is at least 700
and their annual income is at least 3 times the loan amount."
```

```prolog
% Generated by LLM
loan_qualification(Credit, Income, Amount, Tier) :-
    Credit >= 700,
    Income >= Amount * 3,
    Tier = premium.

loan_qualification(Credit, Income, Amount, Tier) :-
    Credit >= 650,
    Credit < 700,
    Income >= Amount * 4,
    Tier = standard.

loan_qualification(Credit, Income, Amount, Tier) :-
    Credit < 650,
    Tier = denied.
```

### Step 2: Convert to DMN for Legal Review

```bash
python -m src.converter loan_rules.pl loan_rules.dmn
```

The DMN file can be opened in DMN editors (Camunda Modeler, Trisotech, etc.) for visual review by legal specialists.

### Step 3: Review and Deploy

- Legal team reviews the DMN decision table visually
- If approved, deploy as either:
  - **Prolog** (for Prolog engines like SWI-Prolog)
  - **DMN** (for DMN engines like Camunda, Drools, etc.)

## Generated DMN Structure

The converter generates valid DMN 1.3 XML with:

- **Decision Tables**: One per Prolog predicate
- **Hit Policy**: UNIQUE (can be customized)
- **Input Columns**: One per input variable
- **Output Columns**: One per output variable
- **Rules**: One row per Prolog clause
- **FEEL Expressions**: Generated from Prolog conditions

## Known Issues & Workarounds

### Issue 1: Multiple Conditions on Same Variable

**Problem**: When a rule has multiple conditions on the same variable, only one appears in DMN.

```prolog
% Original Prolog
rule(X, Y) :- X >= 50, X < 100, Y = medium.
```

**Generated DMN** (only shows one condition):
```xml
<inputEntry><text>< 100</text></inputEntry>
```

**Workaround**: Use range notation in FEEL:
```xml
<inputEntry><text>[50..100)</text></inputEntry>
```

**Future Fix**: Enhance DMN generator to combine multiple conditions on same variable into range or conjunction.

### Issue 2: Data Type Inference

**Problem**: All types default to `string` because Prolog doesn't have explicit types.

**Workaround**: Manually edit DMN to set correct `typeRef` attributes, or add type hints in Prolog comments:

```prolog
% @type Income: number
% @type TaxRate: number
determine_tax_rate(Income, TaxRate) :- ...
```

**Future Fix**: Parse type hint comments.

### Issue 3: Atom vs String

**Problem**: Prolog atoms (like `approved`) are treated as strings in DMN.

**Current Behavior**: Works fine for most use cases.

## Testing

Run the test suite:

```bash
python tests/test_converter.py
```

This tests:
- Prolog → DMN conversion
- DMN → Prolog conversion (roundtrip)
- Validation of examples

## Next Steps for Production Use

### Essential Enhancements

1. **Multi-condition handling**: Combine conditions on same variable
2. **Type inference**: Better data type detection
3. **FEEL functions**: Support DMN built-in functions
4. **Validation**: Semantic validation of business logic
5. **Error messages**: Better error reporting for unsupported Prolog

### Optional Enhancements

1. **DRG support**: Decision Requirement Diagrams
2. **BKM support**: Business Knowledge Models
3. **Context support**: DMN contexts and item definitions
4. **Import/export**: Support for other formats (Excel, CSV)
5. **Visual editor**: Integrated web-based DMN table editor

## Architecture Notes

### Technical Stack

- **Parser**: Lark (LALR parser generator)
- **XML**: lxml (fast, standards-compliant)
- **IR**: Clean intermediate representation for easy extension
- **Python**: 3.8+ compatible

## Troubleshooting

### Parse Errors

If you get a parse error, check:
1. All clauses end with `.`
2. No unsupported Prolog features (cuts, negation, etc.)
3. Variables start with uppercase, atoms with lowercase
4. Strings are quoted with `'` or `"`

### Empty DMN Tables

If the DMN table has no rules:
1. Check that predicates have arguments: `pred(Arg)` not just `pred`
2. Ensure rules have `:-` (not facts)
3. Verify conditions use supported operators

### Type Mismatches

If types don't convert correctly:
1. Add explicit type conversions in DMN
2. Use numeric literals without quotes: `35` not `'35'`
3. Check FEEL expression syntax

## Contributing

Areas for contribution:
- Additional Prolog patterns
- Better type inference
- FEEL expression enhancement
- Documentation improvements
- Example legal/business rules

## License

MIT License - see LICENSE file
