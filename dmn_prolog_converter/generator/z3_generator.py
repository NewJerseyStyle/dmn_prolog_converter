"""
Z3 Generator - Converts Intermediate Representation to Z3 SMT-LIB format.

Generates Z3 SMT-LIB code from the IR.
"""

from typing import Set
from ..ir.intermediate import (
    DecisionModel, Decision, Rule, Condition, Conclusion,
    Variable, Literal, Expression, DataType, OperatorType
)


class Z3Generator:
    """Generate Z3 SMT-LIB code from IR."""

    def __init__(self, indent: str = "  "):
        self.indent = indent
        self.declared_vars: Set[str] = set()

    def generate(self, model: DecisionModel) -> str:
        """Generate Z3 code from DecisionModel."""
        lines = []

        # Add header comment
        lines.append(f"; {model.name}")
        lines.append(f"; Generated by DMN-Prolog-Z3 Converter")
        lines.append("")

        # Generate each decision
        for decision in model.decisions:
            decision_code = self._generate_decision(decision)
            lines.append(decision_code)

        # Add check-sat and get-model (optional)
        lines.append("")
        lines.append("(check-sat)")
        lines.append("(get-model)")

        return "\n".join(lines)

    def generate_file(self, model: DecisionModel, filepath: str):
        """Generate Z3 code file."""
        z3_code = self.generate(model)
        with open(filepath, 'w', encoding='utf-8') as f:
            f.write(z3_code)

    def _generate_decision(self, decision: Decision) -> str:
        """Generate Z3 code for a decision."""
        lines = []

        # Add decision comment
        if decision.description:
            lines.append(f"; {decision.description}")

        # Declare variables (inputs and outputs)
        for var in decision.inputs + decision.outputs:
            if var.name not in self.declared_vars:
                decl = self._declare_variable(var)
                lines.append(decl)
                self.declared_vars.add(var.name)

        # Generate assertions for each rule
        for rule in decision.rules:
            rule_code = self._generate_rule(rule)
            if rule_code:
                lines.append("")
                lines.append(rule_code)

        return "\n".join(lines)

    def _declare_variable(self, var: Variable) -> str:
        """Generate variable declaration."""
        z3_type = self._datatype_to_z3_type(var.data_type)
        return f"(declare-const {var.name} {z3_type})"

    def _generate_rule(self, rule: Rule) -> str:
        """Generate Z3 assertions for a rule."""
        lines = []

        # Add rule description as comment
        if rule.description:
            lines.append(f"; {rule.description}")

        # Generate assertions for conditions
        for condition in rule.conditions:
            assertion = self._generate_condition(condition)
            lines.append(f"(assert {assertion})")

        # Generate assertions for conclusions (assignments)
        for conclusion in rule.conclusions:
            assertion = self._generate_conclusion(conclusion)
            lines.append(f"(assert {assertion})")

        return "\n".join(lines)

    def _generate_condition(self, condition: Condition) -> str:
        """Generate Z3 assertion for a condition."""
        return self._generate_expression(condition.expression)

    def _generate_conclusion(self, conclusion: Conclusion) -> str:
        """Generate Z3 assertion for a conclusion (assignment)."""
        var_name = conclusion.variable.name
        value_expr = self._generate_value(conclusion.value)
        return f"(= {var_name} {value_expr})"

    def _generate_expression(self, expr: Expression) -> str:
        """Generate Z3 expression."""
        if expr.operator in [OperatorType.AND]:
            # Conjunction
            parts = [self._generate_operand(op) for op in expr.operands]
            return f"(and {' '.join(parts)})"

        elif expr.operator in [OperatorType.OR]:
            # Disjunction
            parts = [self._generate_operand(op) for op in expr.operands]
            return f"(or {' '.join(parts)})"

        elif expr.operator == OperatorType.NOT:
            # Negation
            inner = self._generate_operand(expr.operands[0])
            return f"(not {inner})"

        elif len(expr.operands) == 2:
            # Binary operator
            left = self._generate_operand(expr.operands[0])
            right = self._generate_operand(expr.operands[1])
            op_str = self._operator_to_z3(expr.operator)

            return f"({op_str} {left} {right})"

        return ""

    def _generate_operand(self, operand) -> str:
        """Generate Z3 code for an operand."""
        if isinstance(operand, Variable):
            return operand.name
        elif isinstance(operand, Literal):
            return self._generate_literal(operand)
        elif isinstance(operand, Expression):
            return self._generate_expression(operand)
        return str(operand)

    def _generate_literal(self, literal: Literal) -> str:
        """Generate Z3 code for a literal."""
        if literal.data_type == DataType.STRING:
            # Z3 string literals
            return f'"{literal.value}"'
        elif literal.data_type == DataType.BOOLEAN:
            return 'true' if literal.value else 'false'
        elif literal.data_type == DataType.NUMBER:
            return str(literal.value)
        elif literal.data_type == DataType.ATOM:
            # Treat atoms as strings in Z3
            return f'"{literal.value}"'
        else:
            return str(literal.value)

    def _generate_value(self, value) -> str:
        """Generate Z3 code for a value."""
        if isinstance(value, Literal):
            return self._generate_literal(value)
        elif isinstance(value, Expression):
            return self._generate_expression(value)
        return str(value)

    def _operator_to_z3(self, op: OperatorType) -> str:
        """Convert OperatorType to Z3 operator."""
        op_map = {
            # Comparison
            OperatorType.EQ: '=',
            OperatorType.NE: 'distinct',
            OperatorType.GT: '>',
            OperatorType.GTE: '>=',
            OperatorType.LT: '<',
            OperatorType.LTE: '<=',
            # Arithmetic
            OperatorType.ADD: '+',
            OperatorType.SUB: '-',
            OperatorType.MUL: '*',
            OperatorType.DIV: '/',
        }
        return op_map.get(op, '=')

    def _datatype_to_z3_type(self, data_type: DataType) -> str:
        """Convert IR DataType to Z3 type."""
        type_map = {
            DataType.STRING: 'String',
            DataType.NUMBER: 'Int',
            DataType.BOOLEAN: 'Bool',
            DataType.DATE: 'Int',  # Represent dates as integers
            DataType.ATOM: 'String',
        }
        return type_map.get(data_type, 'String')
