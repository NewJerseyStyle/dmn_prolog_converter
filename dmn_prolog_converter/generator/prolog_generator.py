"""
Prolog Generator - Converts Intermediate Representation to Prolog code.

Generates clean, formatted Prolog code from the IR.
"""

from typing import List
from ..ir.intermediate import (
    DecisionModel, Decision, Rule, Condition, Conclusion,
    Variable, Literal, Expression, DataType, OperatorType
)


class PrologGenerator:
    """Generate Prolog code from IR."""

    def __init__(self, indent: str = "    "):
        self.indent = indent

    def generate(self, model: DecisionModel) -> str:
        """Generate Prolog code from DecisionModel."""
        lines = []

        # Add header comment
        lines.append(f"% {model.name}")
        lines.append(f"% Generated by Prolog-DMN Converter")
        lines.append("")

        # Generate each decision
        for i, decision in enumerate(model.decisions):
            if i > 0:
                lines.append("")  # Blank line between decisions

            decision_code = self._generate_decision(decision)
            lines.append(decision_code)

        return "\n".join(lines)

    def generate_file(self, model: DecisionModel, filepath: str):
        """Generate Prolog code file."""
        prolog_code = self.generate(model)
        with open(filepath, 'w', encoding='utf-8') as f:
            f.write(prolog_code)

    def _generate_decision(self, decision: Decision) -> str:
        """Generate Prolog code for a decision."""
        lines = []

        # Add decision comment
        if decision.description:
            lines.append(f"% {decision.description}")

        # Generate each rule
        for rule in decision.rules:
            rule_code = self._generate_rule(rule, decision)
            lines.append(rule_code)

        return "\n".join(lines)

    def _generate_rule(self, rule: Rule, decision: Decision) -> str:
        """Generate Prolog code for a rule."""
        lines = []

        # Add rule description as comment
        if rule.description:
            lines.append(f"% {rule.description}")

        # Build head predicate
        head_args = [var.name for var in decision.inputs + decision.outputs]
        head = f"{decision.name}({', '.join(head_args)})"

        # Build body (conditions + conclusions)
        body_parts = []

        # Add conditions
        for condition in rule.conditions:
            body_parts.append(self._generate_condition(condition))

        # Add conclusions (assignments)
        for conclusion in rule.conclusions:
            assignment = f"{conclusion.variable.name} = {self._generate_value(conclusion.value)}"
            body_parts.append(assignment)

        if body_parts:
            body = f",\n{self.indent}".join(body_parts)
            lines.append(f"{head} :-")
            lines.append(f"{self.indent}{body}.")
        else:
            # Fact (no conditions or conclusions)
            lines.append(f"{head}.")

        return "\n".join(lines)

    def _generate_value(self, value) -> str:
        """Generate Prolog code for a value."""
        if isinstance(value, Literal):
            return self._generate_literal(value)
        elif isinstance(value, Expression):
            return self._generate_expression(value)
        return str(value)

    def _generate_condition(self, condition: Condition) -> str:
        """Generate Prolog code for a condition."""
        return self._generate_expression(condition.expression)

    def _generate_expression(self, expr: Expression) -> str:
        """Generate Prolog code for an expression."""
        if expr.operator in [OperatorType.AND]:
            # Conjunction (comma in Prolog)
            parts = [self._generate_operand(op) for op in expr.operands]
            return f",\n{self.indent}".join(parts)

        elif expr.operator in [OperatorType.OR]:
            # Disjunction (semicolon in Prolog)
            parts = [self._generate_operand(op) for op in expr.operands]
            return f";\n{self.indent}".join(parts)

        elif len(expr.operands) == 2:
            # Binary operator
            left = self._generate_operand(expr.operands[0])
            right = self._generate_operand(expr.operands[1])
            op_str = self._operator_to_prolog(expr.operator)

            return f"{left} {op_str} {right}"

        return ""

    def _generate_operand(self, operand) -> str:
        """Generate Prolog code for an operand."""
        if isinstance(operand, Variable):
            return operand.name
        elif isinstance(operand, Literal):
            return self._generate_literal(operand)
        elif isinstance(operand, Expression):
            return self._generate_expression(operand)
        return str(operand)

    def _generate_literal(self, literal: Literal) -> str:
        """Generate Prolog code for a literal."""
        if literal.data_type == DataType.STRING:
            # Use single quotes for strings in Prolog
            return f"'{literal.value}'"
        elif literal.data_type == DataType.BOOLEAN:
            return str(literal.value).lower()
        elif literal.data_type == DataType.NUMBER:
            return str(literal.value)
        elif literal.data_type == DataType.ATOM:
            # Atoms are lowercase
            val = str(literal.value)
            if val.islower() or val.startswith("'"):
                return val
            else:
                return f"'{val}'"
        else:
            return str(literal.value)

    def _operator_to_prolog(self, op: OperatorType) -> str:
        """Convert OperatorType to Prolog operator."""
        op_map = {
            # Comparison
            OperatorType.EQ: '=',
            OperatorType.NE: '\\=',
            OperatorType.GT: '>',
            OperatorType.GTE: '>=',
            OperatorType.LT: '<',
            OperatorType.LTE: '=<',
            # Arithmetic
            OperatorType.ADD: '+',
            OperatorType.SUB: '-',
            OperatorType.MUL: '*',
            OperatorType.DIV: '/',
        }
        return op_map.get(op, '=')
